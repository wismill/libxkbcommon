#!/usr/bin/env python3

from __future__ import annotations
import argparse
from dataclasses import dataclass
import multiprocessing
import sys
import subprocess
import os
from typing import TYPE_CHECKING, ClassVar, Generator, Optional, TypeAlias
import xml.etree.ElementTree as ET
from pathlib import Path
from ctypes import (
    POINTER,
    Structure,
    _Pointer,
    byref,
    c_char,
    c_char_p,
    c_int,
    cdll,
    create_string_buffer,
    string_at,
)
from ctypes.util import find_library

import wurlitzer

verbose = False

DEFAULT_RULES_XML = "@XKB_CONFIG_ROOT@/rules/evdev.xml"

# Meson needs to fill this in so we can call the tool in the buildir.
EXTRA_PATH = "@MESON_BUILD_ROOT@"
os.environ["PATH"] = ":".join([EXTRA_PATH, os.getenv("PATH", "")])


def escape(s):
    return s.replace('"', '\\"')


# The function generating the progress bar (if any).
def create_progress_bar(verbose):
    def noop_progress_bar(x, total, file=None):
        return x

    progress_bar = noop_progress_bar
    if not verbose and os.isatty(sys.stdout.fileno()):
        try:
            from tqdm import tqdm

            progress_bar = tqdm
        except ImportError:
            pass

    return progress_bar


@dataclass
class RMLVO:
    rules: str = "evdev"
    model: str = "pc105"
    layout: str = "us"
    variant: str = ""
    option: str = ""

    def __iter__(self) -> Generator[str, None, None]:
        yield self.rules
        yield self.model
        yield self.layout
        yield self.variant
        yield self.option


@dataclass
class Invocation(RMLVO):
    exitstatus: int = 77  # default to skipped
    error: str = ""
    keymap: str = ""  # The fully compiled keymap
    command: str = ""

    @property
    def __str(self) -> Generator[str, None, None]:
        rmlvo = ", ".join(f'"{x}"' for x in self)
        yield f"- rmlvo: [{rmlvo}]"
        yield f'  cmd: "{escape(self.command)}"'
        yield f"  status: {self.exitstatus}"
        if self.error:
            yield f'  error: "{escape(self.error.strip())}"'

    def __str__(self) -> str:
        return "\n".join(self.__str)

    def _run(self):
        raise NotImplementedError

    @staticmethod
    def run(i: Invocation):
        i._run()
        return i


@dataclass
class XkbCompInvocation(Invocation):
    xkbcomp_args: ClassVar[list[str]] = ["xkbcomp", "-xkb", "-", "-"]

    def _run(self):
        args = ["setxkbmap", "-print"]
        if self.rules:
            args.append("-rules")
            args.append("{}".format(self.rules))
        if self.model:
            args.append("-model")
            args.append("{}".format(self.model))
        if self.layout:
            args.append("-layout")
            args.append("{}".format(self.layout))
        if self.variant:
            args.append("-variant")
            args.append("{}".format(self.variant))
        if self.option:
            args.append("-option")
            args.append("{}".format(self.option))

        self.command = " ".join(args + ["|"] + self.xkbcomp_args)

        setxkbmap = subprocess.Popen(
            args,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
        )
        stdout, stderr = setxkbmap.communicate()
        if "Cannot open display" in stderr:
            self.error = stderr
            self.exitstatus = 90
        else:
            xkbcomp = subprocess.Popen(
                self.xkbcomp_args,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True,
            )
            stdout, stderr = xkbcomp.communicate(stdout)
            if xkbcomp.returncode != 0:
                self.error = "failed to compile keymap"
                self.exitstatus = xkbcomp.returncode
            else:
                self.keymap = stdout
                self.exitstatus = 0


@dataclass
class XkbcommonInvocation(Invocation):
    UNRECOGNIZED_KEYSYM_ERROR: ClassVar[str] = "XKB-107"

    def _run(self):
        args: tuple[str, ...] = (
            "xkbcli-compile-keymap",  # this is run in the builddir
            "--verbose",
            "--rules",
            self.rules,
            "--model",
            self.model,
            "--layout",
            self.layout,
        )
        if self.variant:
            args += ("--variant", self.variant)
        if self.option:
            args += ("--options", self.option)

        self.command = " ".join(args)

        try:
            output = subprocess.check_output(
                args, stderr=subprocess.STDOUT, universal_newlines=True
            )
            if self.UNRECOGNIZED_KEYSYM_ERROR in output:
                for line in output.split("\n"):
                    if self.UNRECOGNIZED_KEYSYM_ERROR in line:
                        self.error = line
                self.exitstatus = 99  # tool doesn't generate this one
            else:
                self.exitstatus = 0
                self.keymap = output
        except subprocess.CalledProcessError as err:
            self.error = "failed to compile keymap"
            self.exitstatus = err.returncode


################################################################################
# ctypes for xkbcommon
################################################################################


class allocated_c_char_p(c_char_p):
    """
    This class is used in place of c_char_p when we need to free it manually.
    Python would convert c_char_p to a bytes string and we would not be able to free it.
    """

    pass


class xkb_context(Structure):
    pass


class xkb_keymap(Structure):
    pass


class xkb_rule_names(Structure):
    _fields_ = [
        ("rules", POINTER(c_char)),
        ("model", POINTER(c_char)),
        ("layout", POINTER(c_char)),
        ("variant", POINTER(c_char)),
        ("options", POINTER(c_char)),
    ]


# [HACK] Typing ctypes correctly is difficult. The following works, but there
#        could be another better way.
if TYPE_CHECKING:
    xkb_context_p: TypeAlias = _Pointer[xkb_context]
    xkb_rule_names_p: TypeAlias = _Pointer[xkb_rule_names]
    xkb_keymap_p: TypeAlias = _Pointer[xkb_keymap]
else:
    xkb_context_p = POINTER(xkb_context)
    xkb_rule_names_p = POINTER(xkb_rule_names)
    xkb_keymap_p = POINTER(xkb_keymap)
xkb_context_flags = c_int
xkb_keymap_compile_flags = c_int
xkb_keymap_format = c_int

XKB_CONTEXT_NO_DEFAULT_INCLUDES = 1 << 0
XKB_CONTEXT_NO_ENVIRONMENT_NAMES = 1 << 1
XKB_KEYMAP_FORMAT_TEXT_V1 = 1

if libc_path := find_library("c"):
    libc = cdll.LoadLibrary(libc_path)
else:
    raise ValueError("Cannot import libc")

xkbcommon_path = os.environ.get("XKBCOMMON_LIB_PATH")

if xkbcommon_path:
    xkbcommon_path = str(Path(xkbcommon_path).resolve())
    xkbcommon = cdll.LoadLibrary(xkbcommon_path)
else:
    xkbcommon_path = find_library("xkbcommon")
    if xkbcommon_path:
        xkbcommon = cdll.LoadLibrary(xkbcommon_path)
    else:
        raise OSError("Cannot load libxbcommon")

xkbcommon.xkb_context_new.argtypes = [xkb_context_flags]
xkbcommon.xkb_context_new.restype = POINTER(xkb_context)

xkbcommon.xkb_keymap_new_from_names.argtypes = [
    POINTER(xkb_context),
    POINTER(xkb_rule_names),
    xkb_keymap_compile_flags,
]
xkbcommon.xkb_keymap_new_from_names.restype = POINTER(xkb_keymap)

xkbcommon.xkb_keymap_get_as_string.argtypes = [POINTER(xkb_keymap), xkb_keymap_format]
# Note: should be c_char_p; see comment in the definiton of allocated_c_char_p.
xkbcommon.xkb_keymap_get_as_string.restype = allocated_c_char_p


def load_keymap(
    xkb_config_root: Path | None = None,
    rules=None,
    model=None,
    layout=None,
    variant=None,
    options=None,
) -> xkb_keymap_p:
    # Create context
    flags = XKB_CONTEXT_NO_ENVIRONMENT_NAMES
    if xkb_config_root is not None:
        flags |= XKB_CONTEXT_NO_DEFAULT_INCLUDES
    context = xkbcommon.xkb_context_new(flags)
    if not context:
        raise ValueError("Couldn't create xkb context")
    if xkb_config_root is not None:
        raw_path = create_string_buffer(str(xkb_config_root).encode("utf-8"))
        xkbcommon.xkb_context_include_path_append(context, raw_path)
    rmlvo = xkb_rule_names(
        rules=create_string_buffer(rules.encode("utf-8")) if rules else None,
        model=create_string_buffer(model.encode("utf-8")) if model else None,
        layout=create_string_buffer(layout.encode("utf-8")) if layout else None,
        variant=create_string_buffer(variant.encode("utf-8")) if variant else None,
        options=create_string_buffer(options.encode("utf-8")) if options else None,
    )
    # Load keymap
    keymap = xkbcommon.xkb_keymap_new_from_names(context, byref(rmlvo), 0)
    if not keymap:
        raise ValueError(
            f"Failed to compile RMLVO: {rules=}, {model=}, {layout=}, "
            f"{variant=}, {options=}"
        )

    xkbcommon.xkb_context_unref(context)
    return keymap


def keymap_as_string(keymap: xkb_keymap_p) -> str:
    p = xkbcommon.xkb_keymap_get_as_string(keymap, XKB_KEYMAP_FORMAT_TEXT_V1)
    s = string_at(p).decode("utf-8")
    libc.free(p)
    return s


class ForeignKeymap:
    """
    Context manager to ensure proper handling of foreign `xkb_keymap` object.

    Intended use::

        with ForeignKeymap(xkb_base, layout="de") as keymap:
            with ForeignState(keymap) as state:
                # Use state safely here
                state.process_key_event(...)
    """

    def __init__(
        self,
        xkb_base: Optional[Path] = None,
        rules: Optional[str] = None,
        model: Optional[str] = None,
        layout: Optional[str] = None,
        variant: Optional[str] = None,
        options: Optional[str] = None,
    ):
        self.xkb_base = xkb_base
        self._keymap = POINTER(xkb_keymap)()  # NULL pointer
        self.rules = rules
        self.model = model
        self.layout = layout
        self.variant = variant
        self.options = options

    def __enter__(self) -> xkb_keymap_p:
        self._keymap = load_keymap(
            self.xkb_base,
            model=self.model,
            layout=self.layout,
            variant=self.variant,
            options=self.options,
        )
        return self._keymap

    def __exit__(self, exc_type, exc_val, exc_tb):
        xkbcommon.xkb_keymap_unref(self._keymap)

    def check(self) -> bool:
        """
        Test if keymap compiles with corresponding RMLVO config.
        """
        try:
            with self:
                return bool(self._keymap)
        except ValueError:
            return False

    def as_string(self) -> str:
        """
        Export a keymap as a string, or return an empty string on error.
        """
        try:
            with self as keymap:
                if not bool(keymap):
                    return ""
                return keymap_as_string(keymap)
        except ValueError:
            return ""


################################################################################


@dataclass
class XkbcommonLibInvocation(XkbcommonInvocation):
    def _run(self):
        args: tuple[str, ...] = (
            "--rules",
            self.rules,
            "--model",
            self.model,
            "--layout",
            self.layout,
        )
        if self.variant:
            args += ("--variant", self.variant)
        if self.option:
            args += ("--options", self.option)

        self.command = " ".join(args)

        with wurlitzer.pipes(bufsize=65536) as (out, err):
            try:
                keymap = ForeignKeymap(rules=self.rules, layout=self.layout)
                self.keymap = keymap.as_string()
            except ValueError:
                self.error = "failed to compile keymap"
                self.exitstatus = 1
        output = err.read()
        if self.UNRECOGNIZED_KEYSYM_ERROR in output:
            for line in output.split("\n"):
                if self.UNRECOGNIZED_KEYSYM_ERROR in line:
                    self.error = line
            self.exitstatus = 99  # tool doesn't generate this one
        else:
            self.exitstatus = 0
            self.keymap = output + self.keymap


def parse(path, tool):
    root = ET.fromstring(open(path).read())
    layouts = root.findall("layoutList/layout")

    options = tuple(
        e.text or "" for e in root.findall("optionList/group/option/configItem/name")
    )

    count = 0
    for l in layouts:
        count += 1 + len(l.findall("variantList/variant")) * (1 + len(options))

    def iter_combos() -> Generator[Invocation, None, None]:
        for l in layouts:
            layout = l.find("configItem/name").text or ""
            yield tool(layout=layout)

            variants = l.findall("variantList/variant")
            for v in variants:
                variant = v.find("configItem/name").text or ""
                yield tool(layout=layout, variant=variant)

                for option in options:
                    yield tool(layout=layout, variant=variant, option=option)

    return count, iter_combos()


def run(combos, combos_count, tool, njobs, keymap_output_dir):
    if keymap_output_dir:
        keymap_output_dir = Path(keymap_output_dir)
        try:
            keymap_output_dir.mkdir()
        except FileExistsError as e:
            print(e, file=sys.stderr)
            return False

    keymap_file = None
    keymap_file_fd = None

    failed = False
    with multiprocessing.Pool(njobs) as p:
        results = p.imap_unordered(tool.run, combos)
        for invocation in progress_bar(results, total=combos_count, file=sys.stdout):
            if invocation.exitstatus != 0:
                failed = True
                target = sys.stderr
            else:
                target = sys.stdout if verbose else None

            if target:
                print(invocation, file=target)

            if keymap_output_dir:
                # we're running through the layouts in a somewhat sorted manner,
                # so let's keep the fd open until we switch layouts
                layout = invocation.layout
                if invocation.variant:
                    layout += f"({invocation.variant})"
                fname = keymap_output_dir / layout
                if fname != keymap_file:
                    keymap_file = fname
                    if keymap_file_fd:
                        keymap_file_fd.close()
                    keymap_file_fd = open(keymap_file, "a")

                rmlvo = ", ".join(x or "" for x in invocation.rmlvo)
                print(f"// {rmlvo}", file=keymap_file_fd)
                print(invocation.keymap, file=keymap_file_fd)
                if keymap_file_fd:
                    keymap_file_fd.flush()

    return failed


def main(args):
    global progress_bar
    global verbose

    tools = {
        # "libxkbcommon": XkbcommonInvocation,
        "libxkbcommon": XkbcommonLibInvocation,
        "xkbcomp": XkbCompInvocation,
    }

    parser = argparse.ArgumentParser(
        description="""
                    This tool compiles a keymap for each layout, variant and
                    options combination in the given rules XML file. The output
                    of this tool is YAML, use your favorite YAML parser to
                    extract error messages. Errors are printed to stderr.
                    """
    )
    parser.add_argument(
        "path",
        metavar="/path/to/evdev.xml",
        nargs="?",
        type=str,
        default=DEFAULT_RULES_XML,
        help="Path to xkeyboard-config's evdev.xml",
    )
    parser.add_argument(
        "--tool",
        choices=tools.keys(),
        type=str,
        default="libxkbcommon",
        help="parsing tool to use",
    )
    parser.add_argument(
        "--jobs",
        "-j",
        type=int,
        default=(os.cpu_count() or 1) * 4,
        help="number of processes to use",
    )
    parser.add_argument("--verbose", "-v", default=False, action="store_true")
    parser.add_argument(
        "--keymap-output-dir",
        default=None,
        type=str,
        help="Directory to print compiled keymaps to",
    )
    parser.add_argument(
        "--layout", default=None, type=str, help="Only test the given layout"
    )
    parser.add_argument(
        "--variant", default=None, type=str, help="Only test the given variant"
    )
    parser.add_argument(
        "--option", default=None, type=str, help="Only test the given option"
    )

    args = parser.parse_args()

    verbose = args.verbose
    keymapdir = args.keymap_output_dir
    progress_bar = create_progress_bar(verbose)

    tool = tools[args.tool]

    if any([args.layout, args.variant, args.option]):
        combos = (tool(layout=args.layout, variant=args.variant, option=args.option),)
        count = len(combos)
    else:
        count, combos = parse(args.path, tool)
    os.environ["XKB_LOG_LEVEL"] = "debug"
    os.environ["XKB_LOG_VERBOSITY"] = "10"
    failed = run(combos, count, tool, args.jobs, keymapdir)
    sys.exit(failed)


if __name__ == "__main__":
    try:
        main(sys.argv)
    except KeyboardInterrupt:
        print("# Exiting after Ctrl+C")
